#!/bin/bash
# Copyright 2015 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.


# ---------------------------------- NOTE ---------------------------------- #
#
# Please keep the logic in this file consistent with the logic in the
# `flutter.bat` script in the same directory to ensure that Flutter continues
# to work across all platforms!
#
# -------------------------------------------------------------------------- #

set -e

function follow_links() {
  cd -P "${1%/*}"
  local file="$PWD/${1##*/}"
  while [ -h "$file" ]; do
    # On Mac OS, readlink -f doesn't work.
    cd -P "${file%/*}"
    file="$(readlink "$file")"
    cd -P "${file%/*}"
    file="$PWD/${file##*/}"
  done
  echo "$PWD/${file##*/}"
}

# Convert a filesystem path to a format usable by Dart's URI parser.
function path_uri() {
  # Reduce multiple leading slashes to a single slash.
  echo "$1" | sed -E -e "s,^/+,/,"
}

function upgrade_flutter () {
  # This function is executed with a redirect that pipes the source of
  # this script into file descriptor 3.
  #
  # To ensure that we don't simultaneously update Dart in multiple
  # parallel instances, we try to obtain an exclusive lock on this
  # file descriptor (and thus this script's source file) while we are
  # updating Dart and compiling the script. To do this, we try to use
  # the command line program "flock", which is available on many
  # Unix-like platforms, in particular on most Linux distributions.
  # You give it a file descriptor, and it locks the corresponding
  # file, having inherited the file descriptor from the shell.
  #
  # Complicating matters, there are two major scenarios where this
  # will not work. The first is if the platform doesn't have "flock",
  # for example on Mac. There does not appear to be any sort of other
  # equivalent, so on platforms that don't have flock, we just don't
  # do anything.
  #
  # To determine if we have "flock" available, we abuse the "hash"
  # shell built-in to determine if "flock" resolves to anything. If it
  # does, we call it, otherwise we forget the whole thing.
  #
  # The second complication is NFS. On NFS, to obtain an exclusive
  # lock you need a file descriptor that is open for writing, because
  # NFS implements exclusive locks by writing, or some such. Thus, we
  # ignore errors from flock. We do so by using the '|| true' trick,
  # since we are running in a 'set -e' environment wherein all errors
  # are fatal, and by redirecting all output to /dev/null, since
  # users will typically not care about errors from flock and are
  # more likely to be confused by them than helped.
  #
  # The lock is released when the file descriptor goes out of scope,
  # i.e. when this function returns.
  if hash flock 2>/dev/null; then
    flock 3 2>/dev/null || true
  fi

  local revision=`(cd "$FLUTTER_ROOT"; git rev-parse HEAD)`
  if [ ! -f "$SNAPSHOT_PATH" ] || [ ! -s "$STAMP_PATH" ] || [ `cat "$STAMP_PATH"` != "$revision" ] || [ "$FLUTTER_TOOLS_DIR/pubspec.yaml" -nt "$FLUTTER_TOOLS_DIR/pubspec.lock" ]; then
    rm -f "$FLUTTER_ROOT/version"
    mkdir -p "$FLUTTER_ROOT/bin/cache"
    touch "$FLUTTER_ROOT/bin/cache/.dartignore"
    "$FLUTTER_ROOT/bin/internal/update_dart_sdk.sh"

    echo Building flutter tool...
    if [ "$TRAVIS" == "true" ] || [ "$BOT" == "true" ] || [ "$CONTINUOUS_INTEGRATION" == "true" ] || [ "$CHROME_HEADLESS" == "1" ] || [ "$APPVEYOR" == "true" ] || [ "$CI" == "true" ]; then
      PUB_ENVIRONMENT="$PUB_ENVIRONMENT:flutter_bot"
    fi
    export PUB_ENVIRONMENT="$PUB_ENVIRONMENT:flutter_install"

    if [ -d "$FLUTTER_ROOT/.pub-cache" ]; then
      export PUB_CACHE="${PUB_CACHE:-"$FLUTTER_ROOT/.pub-cache"}"
    fi

    while : ; do
      cd "$FLUTTER_TOOLS_DIR"
      "$PUB" upgrade --verbosity=error --no-packages-dir && break
      echo Error: Unable to 'pub upgrade' flutter tool. Retrying in five seconds...
      sleep 5
    done
    "$DART" --snapshot="$SNAPSHOT_PATH" --packages="$FLUTTER_TOOLS_DIR/.packages" "$SCRIPT_PATH"
    echo "$revision" > "$STAMP_PATH"
  fi
}

PROG_NAME="$(path_uri "$(follow_links "$BASH_SOURCE")")"
BIN_DIR="$(cd "${PROG_NAME%/*}" ; pwd -P)"
export FLUTTER_ROOT="$(cd "${BIN_DIR}/.." ; pwd -P)"

FLUTTER_TOOLS_DIR="$FLUTTER_ROOT/packages/flutter_tools"
SNAPSHOT_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.snapshot"
STAMP_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.stamp"
SCRIPT_PATH="$FLUTTER_TOOLS_DIR/bin/flutter_tools.dart"
DART_SDK_PATH="$FLUTTER_ROOT/bin/cache/dart-sdk"

DART="$DART_SDK_PATH/bin/dart"
PUB="$DART_SDK_PATH/bin/pub"

# Test if running as superuser â€“ but don't warn if running within Docker
if [[ "$EUID" == "0" ]] && ! [[ -f /.dockerenv ]]; then
  echo "   Woah! You appear to be trying to run flutter as root."
  echo "   We strongly recommend running the flutter tool without superuser privileges."
  echo "  /"
  echo "ðŸ“Ž"
fi

# Test if Git is available on the Host
if ! hash git 2>/dev/null; then
  echo "Error: Unable to find git in your PATH."
  exit 1
fi
# Test if the flutter directory is a git clone (otherwise git rev-parse HEAD would fail)
if [ ! -e "$FLUTTER_ROOT/.git" ]; then
  echo "Error: The Flutter directory is not a clone of the GitHub project."
  exit 1
fi

# To debug the tool, you can uncomment the following lines to enable checked mode and set an observatory port:
# FLUTTER_TOOL_ARGS="--checked $FLUTTER_TOOL_ARGS"
# FLUTTER_TOOL_ARGS="$FLUTTER_TOOL_ARGS --observe=65432"

(upgrade_flutter) 3< "$PROG_NAME"

set +e
"$DART" $FLUTTER_TOOL_ARGS "$SNAPSHOT_PATH" "$@"

# The VM exits with code 253 if the snapshot version is out-of-date.
# If it is, we need to snapshot it again.
EXIT_CODE=$?
if [ $EXIT_CODE != 253 ]; then
  exit $EXIT_CODE
fi

set -e
"$DART" --snapshot="$SNAPSHOT_PATH" --packages="$FLUTTER_TOOLS_DIR/.packages" "$SCRIPT_PATH"
"$DART" $FLUTTER_TOOL_ARGS "$SNAPSHOT_PATH" "$@"
